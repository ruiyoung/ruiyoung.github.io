--- 
layout:     post
title:      javaScript学习笔记
subtitle:   面向对象
date:       2017-07-01
author:     Ruiyoung
header-img: img/post-bg-debug.png
catalog: true
tags:
    - javaScript
---
### 基本概念  
> 类：每个对象都由类定义，可以把类看做对象的配方。
>> 类不仅要定义对象的的属性和方法，还要定义对象的内部工作工作原理。  
>> JavaScript并没有正式的类，创建一个对象只要定义一个该对象的构造函数并通过它创建对象即可。虽然类并不真正存在，我们也把对象定义叫做类。而且从功能上说，两者是等价的。

> 实例：程序使用类创建对象时，生成的对象叫作类的实例。由类创建对象实例的过程叫做实例化  

> JavaScript 对象定义：可以把对象理解为属性集合，每个属性存放一个原始值、对象或函数  
>> 对象一般认为由方法和属性构成。方法的实质就是函数，而属性的实质就是变量，只不过这里由于它从属于某个对象所以叫法不同。

> 面向对象：可以简单的理解为，不必去了解对象的内部结构，就可以去使用它。就比如我们可以使用手机打电话，但是不必去了解它内部的工作原理。就像我们使用Date对象的方法可以获取和设置时间，单是我们并不用去弄清楚它为什么会实现这个功能。  

### 创建对象的方法
> 本质上都是把"属性"和"方法"，封装成一个对象  


##### 基本模式
缺陷：
- 如果创建多个对象会比较繁琐，效率低
- 实例与原型之间，没有任何办法，可以看出有什么联系  

##### 工厂模式
- 使用创建并返回特定类型的对象的工厂函数(其实就是普通函数，没啥区别，只是叫法不同)  
- 创建过程类似于工厂生产产品的过程，即：原材料--加工--产品...  
- 解决了多次重复创建多个对象的麻烦。  
- 问题：  
&emsp;&emsp;1.创建出的实例之间没有内在的联系，不能反映出它们是同一个原型对象的实例。    
&emsp;&emsp;2.创建对象的时候没有使用 new 关键字  
&emsp;&emsp;3.会造成资源浪费，因为每生成一个实例，都增加一个重复的内容，多占用一些内存。  

##### 构造函数模式  
- new 调用的函数为构造函数，构造函数和普通函数区别仅仅在于是否使用了new来调用。  
- 所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，作为对象的基本结构。  
- 构造函数内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。  
- instanceof 验证原型对象与实例对象之间的关系。  
- 使用call和apply方法实现对象的冒充  
- 问题：浪费内存--使用构造函数每生成一个实例，都增加一个重复的内容，多占用一些内存。这样既不环保，也缺乏效率。  

##### 原型(Prototype)模式  
> Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。可以把那些不变的属性和方法，直接定义在prototype对象上。  
- prototype方式定义的方式，函数不会拷贝到每一个实例中，所有的实例共享prototype中的定义，节省了内存。  
- Prototype模式的验证方法   
&emsp;&emsp;1.isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。    
&emsp;&emsp;2.hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。   
&emsp;&emsp;3.in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。in运算符还可以用来遍历某个对象的所有属性。  
- 对象的constructor属性用于返回创建该对象的构造函数(在JavaScript中，每个具有原型的对象都会自动获得constructor属性)  
- 原型方式的问题:  
&emsp;&emsp;构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值  
&emsp;&emsp;属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享，如果共享的是对象就会造成问题。  

##### 构造函数和原型组合模式 
> 目前最为常用的创建对象的方式。(jQuery类型的封装就是使用组合模式来实例的)   
> 这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。  
> 组合模式还支持向构造函数传递参数，可谓是集两家之所长  
